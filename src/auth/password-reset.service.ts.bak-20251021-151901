import { Injectable } from '@nestjs/common';
import { InjectModel, InjectConnection } from '@nestjs/mongoose';
import { Model, Types, Connection } from 'mongoose';
import * as argon2 from 'argon2';          // para hash do CÓDIGO de 6 dígitos
import * as bcrypt from 'bcryptjs';        // para hash da SENHA do usuário
import { randomBytes } from 'crypto';
import { MailerService } from '@nestjs-modules/mailer';
import { PasswordReset, PasswordResetDocument } from './schemas/password-reset.schema';
import { ForgotPasswordDto } from './dto/forgot-password.dto';
import { ResetWithCodeDto } from './dto/reset-with-code.dto';

async function verifyPassword(plain: string, hashed: string): Promise<boolean> {
  if (!hashed) return false;
  try {
    if (hashed.startsWith('$2a$') || hashed.startsWith('$2b$') || hashed.startsWith('$2y$')) {
      return await verifyPassword(plain, hashed);
    }
    if (hashed.startsWith('$argon2')) {
      return await verifyPassword(hashed, plain);
    }
    // fallback (tenta ambos)
    return (await verifyPassword(plain, hashed)) || (await verifyPassword(hashed, plain).catch(() => false));
  } catch {
    return false;
  }
}


@Injectable()
export class PasswordResetService {
  constructor(
    @InjectModel(PasswordReset.name) private resetModel: Model<PasswordResetDocument>,
    @InjectConnection() private readonly conn: Connection,
    private mailer: MailerService,
  ) {}

  private ttlMinutes() { return Number(process.env.RESET_CODE_TTL_MIN || 15); }
  private buildExpiresAt() { return new Date(Date.now() + this.ttlMinutes() * 60 * 1000); }
  private generateCode6(): string { return (Math.floor(100000 + Math.random() * 900000)).toString(); }

  private getUserModel() {
    return this.conn.models.User || this.conn.model('User', new this.conn.base.Schema({}, { strict: false }));
  }

  async sendResetCode({ email }: ForgotPasswordDto) {
    const UserModel = this.getUserModel();
    const user = await UserModel.findOne({ email }).select('_id email').lean<{ _id: Types.ObjectId; email: string }>();
    if (!user) return { ok: true };

    const code = this.generateCode6();
    const token = randomBytes(32).toString('hex');

    const [codeHash, tokenHash] = await Promise.all([argon2.hash(code), argon2.hash(token)]);
    const expiresAt = this.buildExpiresAt();

    await this.resetModel.create({
      userId: new Types.ObjectId(String(user._id)),
      codeHash,
      tokenHash,
      expiresAt,
    });

    const minutes = this.ttlMinutes();
    const resetUrl = process.env.FRONTEND_RESET_URL
      ? `${process.env.FRONTEND_RESET_URL}?token=${token}`
      : undefined;

    const html = `
      <div style="font-family:Arial,sans-serif">
        <h2>${process.env.APP_NAME || 'MediTrack'}</h2>
        <p>Recebemos um pedido para redefinir sua senha.</p>
        <p><b>Código:</b> <span style="font-size:20px;letter-spacing:3px">${code}</span></p>
        <p>Validade: ${minutes} minutos.</p>
        ${resetUrl ? `<p>Ou clique no link: <a href="${resetUrl}">${resetUrl}</a></p>` : ''}
        <p>Se você não solicitou, ignore este e-mail.</p>
      </div>
    `;

    if (process.env.MAILER_DISABLE_SEND === 'true') {
      if (process.env.RESET_ECHO_CODE_IN_LOGS_DEV === 'true') {
        // NÃO usar em produção!
        // eslint-disable-next-line no-console
        console.log('[RESET] email=' + email + ' code=' + code + ' token=' + token + ' expiresIn=' + minutes + 'm');
      }
    } else {
      await this.mailer.sendMail({ to: email, subject: 'Recuperação de senha', html });
    }

    return { ok: true };
  }

  async resetWithCode({ email, code, newPassword }: ResetWithCodeDto) {
    const UserModel = this.getUserModel();
    const user = await UserModel.findOne({ email });
    if (!user) return { ok: true };

    const now = new Date();
    const req = await this.resetModel.findOne({
      userId: user._id,
      used: false,
      expiresAt: { $gt: now },
    }).sort({ createdAt: -1 });

    if (!req) return { ok: true };
    if (req.attempts >= 5) return { ok: true };

    const ok = await verifyPassword(req.codeHash, code);
    if (!ok) {
      req.attempts += 1;
      await req.save();
      return { ok: true };
    }

    // >>> bcrypt para SENHA do usuário (compatível com seu login)
        // >>> bcrypt para SENHA do usuário (compatível com login)
        // >>> bcrypt para SENHA do usuário (compatível com login)
    const hash = await bcrypt.hash(newPassword, 10);

    // Usa updateOne para evitar hooks de pre('save') do Mongoose
    await this.getUserModel().updateOne(
      { _id: user._id },
      { $set: { password: hash, passwordHash: hash } }
    );

    req.used = true;
    await req.save();

    return { ok: true };
  }
}




