import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as argon2 from 'argon2';
import * as crypto from 'crypto';
import { UsersService } from '../users/users.service';

@Injectable()
export class PasswordResetService {
  constructor(
    @InjectModel('PasswordReset') private readonly resetModel: Model<any>,
    @InjectModel('User') private readonly userModel: Model<any>,
    private readonly users: UsersService,
  ) {}

  async sendResetCode(payload: { email: string }) {
    const { email } = payload;

    const code = Math.floor(100000 + Math.random() * 900000).toString();
    const token = crypto.randomBytes(16).toString('hex');

    const [codeHash, tokenHash] = await Promise.all([
      argon2.hash(code),
      argon2.hash(token),
    ]);

    await this.resetModel.create({
      email,
      codeHash,
      tokenHash,
      consumed: false,
      expiresAt: new Date(Date.now() + 15 * 60 * 1000),
      createdAt: new Date(),
    });

    console.log(`[RESET] email=${email} code=${code} expiresIn=15m`);
    return { ok: true };
  }

  async resetWithCode(payload: { email: string; code: string; newPassword: string }) {
    const { email, code, newPassword } = payload;

    const rec = await this.resetModel
      .findOne({ email })
      .sort({ createdAt: -1 })
      .exec();

    if (!rec) throw new BadRequestException('Código inválido');
    if (rec.consumed) throw new BadRequestException('Código já utilizado');
    if (rec.expiresAt && rec.expiresAt.getTime() < Date.now()) {
      throw new BadRequestException('Código expirado');
    }

    const ok = await argon2.verify(rec.codeHash, code).catch(() => false);
    if (!ok) throw new BadRequestException('Código inválido');

    const user = await this.userModel.findOne({ email }).exec();
    if (!user) throw new BadRequestException('Usuário não encontrado');

    const newHash = await argon2.hash(newPassword);
    await this.userModel
      .updateOne(
        { _id: user._id },
        { $set: { password: newHash, passwordHash: newHash } },
      )
      .exec();

    await this.resetModel
      .updateOne(
        { _id: rec._id },
        { $set: { consumed: true, consumedAt: new Date() } },
      )
      .exec();

    return { ok: true };
  }
}
