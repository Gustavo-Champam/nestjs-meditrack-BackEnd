
    param($m)
    $m.Value + "`r`nimport * as bcrypt from 'bcryptjs';`r`n"
  import * as argon2 from 'argon2';

    param($m)
    $m.Value + "`r`nimport * as bcrypt from 'bcryptjs';`r`n"
  @Injectable()
export class PasswordResetService {
  constructor(
    @InjectModel(PasswordReset.name) private resetModel: Model<PasswordResetDocument>,
    @InjectConnection() private readonly conn: Connection,
    private mailer: MailerService,
  ) {}

  private ttlMinutes() {
    return Number(process.env.RESET_CODE_TTL_MIN || 15);
  }

  private buildExpiresAt() {
    return new Date(Date.now() + this.ttlMinutes() * 60 * 1000);
  }

  private generateCode6(): string {
    return (Math.floor(100000 + Math.random() * 900000)).toString();
  }

  private getUserModel() {
    // Reutiliza modelo existente se já compilado; caso contrário cria "solto" (strict: false)
    return this.conn.models.User || this.conn.model('User', new this.conn.base.Schema({}, { strict: false }));
  }

  async sendResetCode({ email }: ForgotPasswordDto) {
  const UserModel = this.getUserModel();
  const user = await UserModel.findOne({ email }).select('_id email').lean<{ _id: Types.ObjectId; email: string }>();
  if (!user) return { ok: true };

  const code = this.generateCode6();
  const token = randomBytes(32).toString('hex');

  const [codeHash, tokenHash] = await Promise.all([argon2.hash(code), argon2.hash(token)]);
  const expiresAt = this.buildExpiresAt();

  await this.resetModel.create({
    userId: new Types.ObjectId(String(user._id)),
    codeHash,
    tokenHash,
    expiresAt,
  });

  const minutes = this.ttlMinutes();
  const resetUrl = process.env.FRONTEND_RESET_URL
    ? `${process.env.FRONTEND_RESET_URL}?token=${token}`
    : undefined;

  const html = `
        <div style="font-family:Arial,sans-serif">
          <h2>${process.env.APP_NAME || 'MediTrack'}</h2>
          <p>Recebemos um pedido para redefinir sua senha.</p>
          <p><b>Código:</b> <span style="font-size:20px;letter-spacing:3px">${code}</span></p>
          <p>Validade: ${minutes} minutos.</p>
          ${resetUrl ? `<p>Ou clique no link: <a href="${resetUrl}">${resetUrl}</a></p>` : ''}
          <p>Se você não solicitou, ignore este e-mail.</p>
        </div>
      `;

  if (process.env.MAILER_DISABLE_SEND === 'true') {
    if (process.env.RESET_ECHO_CODE_IN_LOGS_DEV === 'true') {
      // NÃO usar em produção!
      console.log('[RESET] email=' + email + ' code=' + code + ' token=' + token + ' expiresIn=' + minutes + 'm');
    }
  } else {
    await this.mailer.sendMail({
      to: email,
      subject: 'Recuperação de senha',
      html,
    });
  }

  return { ok: true };
}async resetWithCode({ email, code, newPassword }: ResetWithCodeDto) {
    const UserModel = this.getUserModel();
    const user = await UserModel.findOne({ email });
    if (!user) return { ok: true };

    const now = new Date();
    const req = await this.resetModel.findOne({
      userId: user._id,
      used: false,
      expiresAt: { $gt: now },
    }).sort({ createdAt: -1 });

    if (!req) return { ok: true };
    if (req.attempts >= 5) return { ok: true };

    const ok = await argon2.verify(req.codeHash, code);
    if (!ok) {
      req.attempts += 1;
      await req.save();
      return { ok: true };
    }

    {
    const hash = await bcrypt.hash(newPassword, 10);
    const anyUser: any = user as any;
    if ('passwordHash' in anyUser) anyUser.passwordHash = hash;
    else if ('password' in anyUser) anyUser.password = hash;
    else anyUser.passwordHash = hash; // fallback
    await user.save();
}req.used = true;
    await req.save();

    return { ok: true };
  }
}




